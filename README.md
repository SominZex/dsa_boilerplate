# DSA Boilerplate

This repository contains a boilerplate for implementing various data structures and algorithms (DSA) in Python, along with utilities for calculating their time complexity. REF: Big_O_Main.py

## Overview

This DSA boilerplate aims to provide a structured foundation for implementing and analyzing common data structures and algorithms. It includes:

- Implementations of various data structures, such as arrays, linked lists, stacks, queues, trees, and graphs.
- Implementations of classic algorithms, including sorting, searching, and graph algorithms.
- Utilities for calculating the time complexity of algorithms using both theoretical and empirical methods.
- Examples and usage instructions to help you get started with using the boilerplate for your DSA projects.

## Features

- **Data Structures**: Implementations of common data structures including:
  - Arrays
  - Linked Lists (Singly and Doubly)
  - Stacks
  - Queues (including Priority Queue)
  - Trees (Binary Search Tree, AVL Tree, Heap, etc.)
  - Graphs (Adjacency Matrix and Adjacency List)
  - Hash Tables (Hash Map)
- **Modular Structure**: Each data structure and algorithm is implemented in a separate module for easy navigation and reuse.
- **Clear Documentation**: Detailed comments and docstrings are provided for each function and class to explain their purpose and usage.
- **Time Complexity Analysis**: Utilities are included for calculating the time complexity of algorithms analytically and empirically, helping you understand and compare their performance.
- **Examples and Tests**: Examples and test cases are provided to demonstrate the usage of data structures and algorithms and ensure their correctness.
- **Algorithms**: Implementations of classic algorithms including:
  - Sorting Algorithms (Bubble Sort, Insertion Sort, Selection Sort, Merge Sort, Quick Sort, etc.)
  - Searching Algorithms (Linear Search, Binary Search)
  - Graph Algorithms (Breadth-First Search, Depth-First Search, Dijkstra's Algorithm, Bellman-Ford Algorithm, Prim's Algorithm, Kruskal's Algorithm, etc.)
  - String Algorithms (String Matching, Longest Common Subsequence, etc.)
  - Dynamic Programming Algorithms (Fibonacci Series, Knapsack Problem, Longest Increasing Subsequence, etc.)
  - Minimum Spanning Tree included
  - The Travelling Salesman included
  - Shortest Path Calculation Included
  - Maximum Flow/Cut included

- **Time Complexity Analysis**: Utilities for calculating the time complexity of algorithms using both theoretical and empirical methods. This includes tools for analyzing the time complexity of individual algorithms as well as comparing the performance of different algorithms.

## Usage

1. Clone the repository to your local machine
2. import the Algorithm developed as module from specific directory. i.e. from Algorithms.binary_search.binary_search import Graph
3. No depencies or enternal modules are required, you can run with basic python3 packages.
4. Explore the `Data_Structures` and `Algorithms` directories to find the implementations you need.
5. Use the provided utilities in the `Big_O_Main.py` file to analyze the time complexity of algorithms in your project.
5. Refer to the examples and documentation within each module for guidance on usage and integration into your projects.

